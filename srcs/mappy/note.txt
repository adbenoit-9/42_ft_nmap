

MAPPY
For integrate a module in mappy we have to instanciate a compile-time array of hook

t_func_mappy _exec_module[MAX_EXECUTION_HOOK] = {
	{
		build_smthg,
		NULL,
	}

For exposing a function to sety we need to define its index
#define BUILDY_HOOK_INDEX0 0
Finaly this array of function must be instanciate at compile time in the main _exec
		_exec[MAX_EXECUTION_CMD][MAX_EXECUTION_HOOK] {
			_exec_build,
			NULL
		};
apped functions sould respect this prototype
		int 				proto_exec(uint8_t *buf, void *conf_st, void *conf_nd, void *conf_exec)


User may want to change MAX_EXECUTION_CMD MAX_EXECUTION_HOOK



/*
 **
 ** At the execution mappy will check in execution_task_list of t_exec_proto of third level
 ** tree. TASK_EXECUTION_TODO_MSK != 0 it will lock this value to 0 and mappy will call
 * (*_exec[execution_task_list[i]][execution_target[i]])
 ** 
 */

/*
 ** Samples :
 **
 */

typedef struct		s_st {
	t_mappy_proto				cross;
	uint8_t 					st_flag;
}					t_st;

typedef struct		s_nd {
	t_mappy_proto				cross;
	uint8_t 					nd_flag;
}					t_nd;

typedef struct		s_result {
	t_exec_proto				cross;
	uint8_t						exec_flag;
}					t_result;


/*
 ** TODO
 ** #define HOOK_TARGET(index_st, index nd) ((index_st * HOOK_INDEX_ND_MAX) + index_nd)
 ** 
 **
 */

/*
   Example of use :

   typedef struct		s_st {
   t_mappy_proto				cross;
   uint8_t 					st_flag;
   }					t_st;

   typedef struct		s_nd {
   t_mappy_proto				cross;
   uint8_t 					nd_flag;
   }					t_nd;

   typedef struct		s_result {
   t_exec_proto				cross;
   uint8_t						exec_flag;
   }					t_result;

   int 				add_sample_1(uint8_t *buf, void *conf_st, void *conf_nd, void *conf_exec)
   {
   int j = 0;

   while (j < MAX_BUFFER_SIZE)
   {
   buf[j] += ((t_st*)conf_st)->st_flag;
   buf[j] += ((t_nd*)conf_nd)->nd_flag;
   buf[j] += ((t_exec*)conf_exec)->exec_flag;
   j++;
   }
   return (0);
   }
   int 				sub_sample_1(uint8_t *buf, void *conf_st, void *conf_nd, void *conf_exec)
   {
   int j = 0;

   while (j < MAX_BUFFER_SIZE)
   {
   buf[j] -= ((t_st*)conf_st)->st_flag;
   buf[j] -= ((t_nd*)conf_nd)->nd_flag;
   buf[j] -= ((t_exec*)conf_exec)->exec_flag;
   j++;
   }
   return (0);
   }
   int 				mul_sample_1(uint8_t *buf, void *conf_st, void *conf_nd, void *conf_exec)
   {
   int j = 0;

   while (j < MAX_BUFFER_SIZE)
   {
   buf[j] *= ((t_st*)conf_st)->st_flag;
   buf[j] *= ((t_nd*)conf_nd)->nd_flag;
   buf[j] *= ((t_exec*)conf_exec)->exec_flag;
   j++;
   }
   return (0);
   }

#define HOOK_INDEX_ND_MAX
#define HOOK_INDEX_ST_MAX
#define HOOK_TARGET(index_st, index nd) ((index_st * HOOK_INDEX_ND_MAX) + index_nd)

typedef int (*t_func_mappy)(uint8_t *, void *, void *, void *);

		// TODO
		// cmocka test
		// the buffer[MAX_BUFFER_SIZE] is checked entirely before and after
		// can return a dump of the buffer somewhere (to dumpy ?)

		t_func_mappy _exec[MAX_EXECUTION_CMD][MAX_EXECUTION_HOOK] = {
		{
		build_ipv4_tcp,
		NULL,
},
{
	build_ipv4_tcp,
	NULL,
},
	};

*/
